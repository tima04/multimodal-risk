# -*- coding: utf-8 -*-
import random
import time
import training
import json
from psychopy import core, visual, event, sound
from abc import ABCMeta, abstractmethod
from parameters import *
from pygame import mixer
from utilities import *

def main():
    data = {'start_time': timestamp()}
    data['play'] = True
    try:
        data['id'] = dialog_box()[0]
    except:
        return None
    win = visual.Window([800, 600], allowGUI=True, units='deg',
                        color = "grey",fullscr=FULLSCREEN, monitor="testMonitor")
    dominant_stimulie = get_dominant_stimulie(data['id'])
    choices = random_choices4play(data['id'], NPLAY)
    blocks =  [Visual(win, dominant_stimulie[0], choices["Visual"]),
               Auditory(win, dominant_stimulie[1], choices["Auditory"]), 
               Semantic(win, dominant_stimulie[1], choices["Semantic"])]
    data['choices'] = choices
    data['total_win'] = 0
    for block in blocks:
        corrects = block.play()
        for i in range(0, len(corrects)):
            if corrects[i]:
                data['total_win'] += choices[str(block)][i]['amount']
            data['choices'][str(block)][i]['correctp'] = corrects[i]
    data['finish_time'] = timestamp()
    save_data(data)
    txt = u"You win 10 percent of \u20AC %s."%data['total_win']
    visual.TextStim(win, text=txt, pos=(0,0)).draw()
    win.flip()
    event.waitKeys()

class Play(training.Training):
    def __init__(self, win, dominant_stimulus, choices):
        training.Training.__init__(self, win, dominant_stimulus)
        self.win = win
        self.choices = choices

    def play(self):
        corrects = []
        for choice in self.choices:
            self.show_choice_info(choice)
            stim = choice['stim']
            if stim == 1:
                self._render_stimulus(self.stimulus1)
            else:
                self._render_stimulus(self.stimulus2)
            key, duration = self._get_key()
            correctp = self._give_feedback(key, stim)
            corrects.append(correctp)
            self._show_inter_trial_win()
        return corrects
    
    def show_choice_info(self, choice):
        txt = u"Correct classification in the next %s task will win you \u20AC%s. Please press any key to continue"%(self.__str__().lower(), choice['amount'])
        visual.TextStim(self.win, text=txt, pos=(0, 0)).draw()
        self.win.flip()
        event.waitKeys()

        
class Visual(Play, training.Visual):
    def __init__(self, win, dominant_stimulus, stims):
        Play.__init__(self, win, dominant_stimulus, stims)
        training.Visual.__init__(self, win, dominant_stimulus)


class Auditory(Play, training.Auditory):
    def __init__(self, win, dominant_stimulus, stims):
        Play.__init__(self, win, dominant_stimulus, stims)
        training.Auditory.__init__(self, win, dominant_stimulus)


class Semantic(Play, training.Semantic):
    def __init__(self, win, dominant_stimulus, stims):
        Play.__init__(self, win, dominant_stimulus, stims)
        training.Semantic.__init__(self, win, dominant_stimulus)


def random_choices4play(id_, nchoice):
    """randomly select a run generated by the choice_task and from that
    randomly select nchoice choices from each modualies to be played 
    for real. The return value is a dictionary of a form:
    rslt['Visual'] = [{'stim': 1, 'amount': 10}, {'stim': 2, 'amount': 20}]
    """

    def extract_choices(trials):
        """helper function, trials is a list generated by choice_task for a 
        particular modulaty, returns a list of dictionary with keys 'stim'
        and 'amount'. """
        rslts = []
        other = {1: 2, 2: 1} # other[1] = 2, other[2] = 1
        for trial in trials:
            first_stim = trial.get('first_stim', 
                                   other.get(trial.get('second_stim')))
            second_stim = trial.get('second_stim', other[first_stim])
            rslt = {}
            # if the subjece did not pressed any key then she still gets 
            # to play the second_stim.
            if trial['key'] == "left":
                rslt['stim'] = first_stim
                rslt['amount'] = trial["left_outcome"]
            else:
                rslt['stim'] = second_stim
                rslt['amount'] = trial["right_outcome"]
            rslts.append(rslt)
        return rslts
    
    dir_ = os.path.join(os.path.dirname(__file__), "..", 'subjects_data')
    tp = 'fmri' if IS_FMRI else "behavioral"
    fls = get_data_files(id_, dir_, ptrn='%s_choice_data'%tp)
    if not fls:
        print "Choice data not found, did you give the correct id?"
        return
    fl = random.choice(fls) # choose a run randomly
    print fl
    data = json.load(open(os.path.join(dir_, fl)))
    rslt = {}
    for block in ["Visual", "Auditory", "Semantic"]:
        rslt[block] = extract_choices(random.sample(data[block]['trials'], 
                                                    nchoice))
    return rslt
        
if __name__=="__main__":
    main()
